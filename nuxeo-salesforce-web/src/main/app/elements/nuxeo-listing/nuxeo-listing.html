<dom-module id="nuxeo-listing" assetpath="nuxeo-listing/">
  <style>
    :host {
      display: block;
    }

    .item {
      padding-top: 0.5em;
      margin: 5px;
      height: 1em;
      background-color: white;
      display: inline-block;
      width: 300px;
      overflow: hidden;
      cursor: pointer;
      user-select: none;
    @apply(--shadow-elevation-2dp);
    }

    .item[selected] {
      font-weight: bold;
      border-left-color: var(--default-primary-color);
      border-left-style: solid;
    }

    .breadcumb {
      margin: 5px;
    }

    .path {
      display: inline-block;
      vertical-align: middle;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
    }

    .path {
      padding: 5px;
      text-decoration: none;
      color: black;
      display: inline-block;
    }

    .path:last-of-type {
      color: #aaa;
      pointer-events: none;
    }

    @media (max-width: 600px) {
      h1.paper-font-display1 {
        font-size: 24px;
      }
    }

    .hover {
      background: var(--light-primary-color);
    }

    .list {
      height: 500px;
    }

    a {
      color:inherit;
      text-decoration: none;
    }
  </style>
  <template>
    <!-- Nuxeo and Salesforce connections -->
    <nx-connection id="nx"></nx-connection>


    <nx-resource id="oauth2directory" path="/oauth2directory/salesforce" response="{{result}}" auto></nx-resource>
    <nx-salesforce-connection id="sf" callback="[[result.userAuthorizationURL]]" clientid="[[result.clientId]]" sfobject="{{sfobject}}"></nx-salesforce-connection>


    <!-- Nuxeo resources -->
    <nx-resource id="parentResource" response="{{currentParent}}"></nx-resource>
    <nx-resource id="query" path="/query" response="{{response}}" enrichers="preview, documentURL, driveEditURL"></nx-resource>
    <nx-operation id="fetchSFObject" op="javascript.FetchSFObject" enrichers="documentURL" params="[[params]]" response="{{currentParent}}"></nx-operation>
    <nx-operation id="getChildren" op="Document.GetChildren" input="[[currentParent.path]]" response="{{response}}"></nx-operation>
    <nx-operation id="CreateFolder" op="Document.Create" input="[[currentParent.path]]" params="[[params]]"></nx-operation>

    <div class="breadcumb">
      <template is="dom-repeat" items="[[_splitPath(currentParent.path)]]">
        / <span class="path" on-tap="_up">[[item]]</span>
      </template>
      <a href="[[_docURL(currentParent)]]" target="_blank"><paper-tooltip>Access</paper-tooltip>
        <i class="material-icons">open_in_new</i></a>
    </div>

    <section class="sub_toolbar_actions" onclick="createFolderBox(event)">
      <paper-button tabindex="0" data-dialog="create_folder_box"><iron-icon icon="folder"></iron-icon>add folder</paper-button>
    </section>
    <paper-dialog id="create_folder_box" class="folder-box">
      <h3>Add folder</h3>
      <div>
        <paper-input id="folder_name" placeholder="Folder Title" value="{{folderName}}" required="" auto-validate="" error-message="The folder title is required">
        </paper-input>
      </div>
      <div class="buttons">
        <paper-button dialog-dismiss="">Cancel</paper-button>
        <paper-button dialog-confirm="" on-tap="_createFolder">Create</paper-button>
      </div>
    </paper-dialog>

    <div id="list" class="list">
      <template is="dom-if" if="[[_isEmpty(response)]]">
        There is no related document
      </template>
      <template is="dom-repeat" items="[[response.entries]]">
        <paper-item class="item" on-tap="_select" selected$="[[_isSame(item, selected)]]">
          <img src="[[_iconFor(item)]]"><span>[[item.title]]</span>
          <template is="dom-if" if="[[_isNotFolder(item)]]">
            <div class="row_actions">
              <a href="[[_preview(item)]]" target="_blank"><paper-tooltip>Preview the document</paper-tooltip>
                <i class="material-icons">visibility</i></a>
              <a href="[[_downloadURL(item)]]" target="_blank"><paper-tooltip>Download the document</paper-tooltip>
                <i class="material-icons">get_app</i></a>
              <a href="[[_docURL(item)]]" target="_blank"><paper-tooltip>Edit in Nuxeo</paper-tooltip>
                <i class="material-icons">create</i></a>
              <a href="[[_driveEdit(item)]]"><paper-tooltip>Edit in Nuxeo Drive</paper-tooltip>
                <i class="material-icons">insert_drive_file</i></a>
              <template is="dom-if" if="[[_isLock(item)]]">
                <i class="material-icons">lock</i>
              </template>
            </div>
          </template>
        </paper-item>
      </template>
    </div>

  </template>

  <script>
    function validate() {
      document.getElementById('folder_name').validate();
    }
    function createFolderBox(e) {
      var button = e.target;
      while (!button.hasAttribute('data-dialog') && button !== document.body) {
        button = button.parentElement;
      }
      if (!button.hasAttribute('data-dialog')) {
        return;
      }
      var id = button.getAttribute('data-dialog');
      var dialog = document.getElementById(id);
      if (dialog) {
        dialog.open();
      }
    }
    (function() {
      Polymer({
        is: 'nuxeo-listing',
        properties: {
          path: {
            type: String,
            value: '/default-domain'
          },
          searchTerm: {
            type: String,
            notify: true
          },
          currentParent: {
            type: Object,
            notify: true
          },
          selected: {
            type: Object,
            notify: true
          },
          params: {
            type:Object,
            value: {}
          },
          folderName: {
            type: String
          },
          sfobject: {
            type: Object
          }
        },

        observers: [
          '_fetch(currentParent.uid, searchTerm, sfobject)',
          '_displayCanvasApp(sfobject)',
          '_executeOp(sfobject)',
          '_getChildren(currentParent)'
        ],

        listeners: {
          'list.dragover': '_onDragOver',
          'list.dragenter': '_onDragEnter',
          'list.drop': '_onDrop',
          'list.dragleave': '_onDragLeave'
        },

        _displayCanvasApp: function () {
          if (this.sfobject) {
            $(".fullbleed").show();
          } else {
            $(".fullbleed").hide();
          }
        },

        _executeOp: function(){
          this.params.sfobjectId = this.sfobject.Id;
          this.params.sfobjectName = this.sfobject.Name;
          this.$.fetchSFObject.execute();
        },

        _isEmpty: function(response){
          return response===null || response.resultsCount === 0;
        },

        _fetchParent: function(path) {
          this.$.parentResource.path = '/path' + path;
          return this.$.parentResource.get();
        },

        _fetch: function(parentId, searchTerm) {
          this.$.query.params = this._getQueryParams(parentId, searchTerm);
          this.$.query.get();
        },

        _createFolder: function() {
          this.params.name=this.folderName;
          this.params.type="Folder";
          this.params.properties = {};
          this.params.properties["dc:title"]=this.folderName;
          this.$.CreateFolder.execute().then(function() {
            return this.$.query.get();
          }.bind(this));
        },

        _getChildren: function(){
          if(this.currentParent){
            this.$.getChildren.execute();
          }
        },

        _select: function(e) {
          var item = e.model.item;
          // if folder and already selected navigate to it (dbl click)
          if (this._isFolder(item)) {
            this.selected = undefined; // clear selection
            this.searchTerm = ''; // clear search term
            this.currentParent = item;
          } else {
            if (this._isSame(item, this.selected) && window.opener) {
              window.opener.postMessage(item, '*');
            }
            this.selected = item;
          }
        },

        _up: function(e) {
          var pathParts = this._splitPath(this.currentParent.path);
          var parentPath = '/' + pathParts.splice(0, e.model.index + 1).join('/');
          this._fetchParent(parentPath);
        },

        _isSame: function(item, selected) {
          return selected && selected.uid === item.uid;
        },

        _getQueryParams: function(parentId, searchTerm) {
          var query = 'SELECT * FROM Document WHERE ecm:currentLifeCycleState != \'deleted\' ' +
            ' AND ecm:isCheckedInVersion = 0 ' +
            ' AND ecm:mixinType != \'HiddenInNavigation\' ';

          if (searchTerm) {
            return {
              query: query + ' AND ecm:parentId = ?' + ' AND ecm:fulltext=\'' + searchTerm + '*\'',
              queryParams: parentId
            };
          }
          return {
            query: query + ' AND ecm:parentId = ?',
            queryParams: parentId
          };
        },

        _iconFor: function(doc) {
          if (doc.properties['common:icon']) {
            return this.$.nx.client._baseURL + doc.properties['common:icon'];
          }
        },

        _preview: function(doc) {
          if(doc.contextParameters!==undefined){
            if(doc.contextParameters.preview!==undefined) {
              return doc.contextParameters.preview.url;
            } else {
              return doc.contextParameters.documentURL;
            }
          }
        },

        _isLock: function(doc) {
          return doc.lockOwner!==undefined;
        },

        _docURL: function(doc) {
          if(doc && doc.contextParameters!==undefined){
            return doc.contextParameters.documentURL;
          }
        },

        _driveEdit: function(doc) {
          if(doc.contextParameters!==undefined){
            return doc.contextParameters.driveEditURL;
          }
        },

        _downloadURL: function(doc) {
          if(doc.properties["file:content"]!==undefined && doc.properties["file:content"]!==null){
            return doc.properties["file:content"].data;
          }else{
            if(doc.contextParameters!==undefined){
              return doc.contextParameters.documentURL;
            }
          }
        },

        _isFolder: function(doc) {
          return doc.facets.some(function(e){ return e === 'Folderish'; });
        },

        _isNotFolder: function(doc) {
          return doc.facets.indexOf("Folderish") < 0;
        },

        _splitPath: function(path) {
          return (path) ? path.split('/').splice(1) : [];
        },

        _onDragOver: function(e) {
          // prevent default to allow drop
          e.preventDefault();
        },
        _onDragEnter: function(e) {
          this.toggleClass('hover', true, e.target);
        },
        _onDrop: function (e) {
          e.preventDefault();
          this.toggleClass('hover', false, e.target);
          this._upload(e.dataTransfer.files).then(function(docs) {
            // refresh and select last file uploaded
            return this.$.query.get().then(function() {
              this.selected = docs.entries.pop();
            }.bind(this));
          }.bind(this));
          return false;
        },
        _onDragLeave: function(e) {
          this.toggleClass('hover', false, e.target);
        },

        _upload: function(files) {
          var uploader = this.$.nx.client
            .operation('FileManager.Import')
            .context({ currentDocument: this.currentParent.path })
            .uploader();
          var uploads = [];
          for (var i = 0; i < files.length; i++) {
            uploads.push(new Promise(function (resolve, reject) {
              uploader.uploadFile(files[i], function (data) {
                resolve(data);
              });
            }));
          }
          return Promise.all(uploads)
            .then(function() {
              return new Promise(function (resolve, reject) {
                uploader.execute(function (error, data) {
                  (error) ? reject(error) : resolve(data);
                });
              });
            });
        }
      });
    })();
  </script>
</dom-module>
