<dom-module id="nuxeo-listing" assetpath="nuxeo-listing/">
  <style>
    :host {
      display: block;
    }

    .item {
      padding-top: 0.5em;
      margin: 5px;
      height: 1em;
      background-color: white;
      display: inline-block;
      width: 300px;
      overflow: hidden;
      cursor: pointer;
      user-select: none;
    @apply(--shadow-elevation-2dp);
    }

    .item[selected] {
      font-weight: bold;
      border-left-color: var(--default-primary-color);
      border-left-style: solid;
    }

    .breadcumb {
      margin: 5px;
    }

    .path {
      display: inline-block;
      vertical-align: middle;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
    }

    .path {
      padding: 5px;
      text-decoration: none;
      color: black;
      display: inline-block;
    }

    .path:last-of-type {
      color: #aaa;
      pointer-events: none;
    }

    @media (max-width: 600px) {
      h1.paper-font-display1 {
        font-size: 24px;
      }
    }

    .hover {
      background: var(--light-primary-color);
    }
  </style>
  <template>
    <nx-connection id="nx"></nx-connection>

    <nx-resource id="parentResource" response="{{currentParent}}"></nx-resource>
    <nx-resource id="query" path="/query" response="{{response}}"></nx-resource>
    <nx-operation id="OpportunityDocuments" op="opportunitychain" params="{{params}}" response="{{response}}"></nx-operation>

    <div class="breadcumb">
      <template is="dom-repeat" items="[[_splitPath(currentParent.path)]]">
        / <span class="path" on-tap="_up">[[item]]</span>
      </template>
    </div>

    <div id="list" class="list">
      <template is="dom-repeat" items="[[response.entries]]">
        <paper-item class="item" on-tap="_select" selected$="[[_isSame(item, selected)]]">
          <img src="[[_iconFor(item)]]"> <span>[[item.title]]</span>
        </paper-item>
      </template>
    </div>

  </template>

  <script>
    (function() {
      var isLogin = Sfdc.canvas.oauth.loggedin();
      if(isLogin){
        sessionStorage.setItem("client", JSON.stringify(Sfdc.canvas.oauth.client()));
      } else {
        var uri = Sfdc.canvas.oauth.loginUrl();
        Sfdc.canvas.oauth.login({
          uri: uri,
          params: {
            response_type: "token",
            client_id: "3MVG9KI2HHAq33Rw3X7mQauk5.B.uuz_9Q8V8spV9ydsDyov4MaFEvyrajf2BKGgedc.W4WXaupu0q2dkEA_y",
            redirect_uri: encodeURIComponent("https://172.28.255.143:8443/nuxeo/picker/callback/callback.html")
          }
        });
      }
      Polymer({
        is: 'nuxeo-listing',
        created: function() {
          this._isLogin = isLogin;
          this._getCtx();
        },
        properties: {
          path: {
            type: String,
            value: '/default-domain'
          },
          searchTerm: {
            type: String,
            notify: true
          },
          currentParent: {
            type: Object,
            notify: true
          },
          selected: {
            type: Object,
            notify: true
          },
          opportunity: {
            type: Object,
            notify: true
          },
          params: {
            type:Object,
            value: {}
          }
        },

        observers: [
          '_fetch(currentParent.uid, searchTerm)',
          '_executeOp(opportunity)'
        ],

        listeners: {
          'list.dragover': '_onDragOver',
          'list.dragenter': '_onDragEnter',
          'list.drop': '_onDrop',
          'list.dragleave': '_onDragLeave'
        },

        _getCtx: function(){
          if (this._isLogin) {
            var callback = this._callbackCtx.bind(this);
            Sfdc.canvas.client.ctx(callback, JSON.parse(sessionStorage.getItem("client")));
          }
        },

        _callbackCtx: function(ctx){
          var opId = ctx.payload.environment.record.Id;
          var queryUrl = ctx.payload.links.queryUrl;
          var soqlQuery = "SELECT Name, id from Opportunity where id='" + opId + "'";
          var callbackOp = this._callbackOpportunity.bind(this);
          var settings = {
            client: JSON.parse(sessionStorage.getItem("client")),
            method: 'GET',
            async: true,
            contentType: "application/json",
            success: callbackOp
          }
          Sfdc.canvas.client.ajax(queryUrl + "?q=" + soqlQuery, settings);
        },

        _callbackOpportunity: function(response){
          this.opportunity = response.payload.records[0];
        },

        _executeOp: function(opportunity){
          this.params.opportunityId = opportunity.Id;
          this.params.opportunityName = opportunity.Name;
          this.$.OpportunityDocuments.execute();
        },

        _fetchParent: function(path) {
          this.$.parentResource.path = '/path' + path;
          return this.$.parentResource.get();
        },

        _fetch: function(parentId, searchTerm) {
          this.$.query.params = this._getQueryParams(parentId, searchTerm);
          this.$.query.get();
        },

        _select: function(e) {
          var item = e.model.item;
          // if folder and already selected navigate to it (dbl click)
          if (this._isSame(item, this.selected) && this._isFolder(item)) {
            this.selected = undefined; // clear selection
            this.searchTerm = ''; // clear search term
            this.currentParent = item;
          } else {
            if (this._isSame(item, this.selected) && window.opener) {
              window.opener.postMessage(item, '*');
            }
            this.selected = item;
          }
        },

        _up: function(e) {
          var pathParts = this._splitPath(this.currentParent.path);
          var parentPath = '/' + pathParts.splice(0, e.model.index + 1).join('/');
          this._fetchParent(parentPath);
        },

        _isSame: function(item, selected) {
          return selected && selected.uid === item.uid;
        },

        _getQueryParams: function(parentId, searchTerm) {
          var query = 'SELECT * FROM Document WHERE ecm:currentLifeCycleState != \'deleted\' ' +
            ' AND ecm:isCheckedInVersion = 0 ' +
            ' AND ecm:mixinType != \'HiddenInNavigation\' ';

          if (searchTerm) {
            return { query: query + ' AND ecm:fulltext=\'' + searchTerm + '*\''};
          }
          return {
            query: query + ' AND ecm:parentId = ?',
            queryParams: parentId
          };
        },

        _iconFor: function(doc) {
          if (doc.properties['common:icon']) {
            return this.$.nx.client._baseURL + doc.properties['common:icon'];
          }
        },

        _isFolder: function(doc) {
          return doc.facets.some(function(e){ return e === 'Folderish'; });
        },

        _splitPath: function(path) {
          return (path) ? path.split('/').splice(1) : [];
        },

        _onDragOver: function(e) {
          // prevent default to allow drop
          e.preventDefault();
        },
        _onDragEnter: function(e) {
          this.toggleClass('hover', true, e.target);
        },
        _onDrop: function (e) {
          e.preventDefault();
          this.toggleClass('hover', false, e.target);
          this._upload(e.dataTransfer.files).then(function(docs) {
            // refresh and select last file uploaded
            return this.$.query.get().then(function() {
              this.selected = docs.entries.pop();
            }.bind(this));
          }.bind(this));
          return false;
        },
        _onDragLeave: function(e) {
          this.toggleClass('hover', false, e.target);
        },

        _upload: function(files) {
          var uploader = this.$.nx.client
            .operation('FileManager.Import')
            .context({ currentDocument: this.currentParent.path })
            .uploader();
          var uploads = [];
          for (var i = 0; i < files.length; i++) {
            uploads.push(new Promise(function (resolve, reject) {
              uploader.uploadFile(files[i], function (error, data) {
                (error) ? reject(error) : resolve(data);
              });
            }));
          }
          return Promise.all(uploads)
            .then(function() {
              return new Promise(function (resolve, reject) {
                uploader.execute(function (error, data) {
                  (error) ? reject(error) : resolve(data);
                });
              });
            });
        }
      });
    })();
  </script>
</dom-module>
